<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Swim Controller V13</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@700&display=swap');
    body { font-family: 'Roboto Mono', monospace; background-color: #000; color: white; margin: 0; overflow: hidden; }
    .digital-font { font-variant-numeric: tabular-nums; letter-spacing: -5px; }
    .scroll-container { height: calc(100vh - 340px); overflow-y: auto; padding-bottom: 80px; }

    /* Use dvh (dynamic viewport height) for mobile browser chrome compatibility */
    .run-container {
      height: 100vh;
      height: 100dvh; /* Modern browsers - accounts for browser chrome */
    }

    /* Responsive timer sizing - uses smaller of width or height */
    .timer-display {
      font-size: min(45vw, 60dvh, 60vh);
      line-height: 1;
    }

    /* Landscape-specific adjustments */
    @media (orientation: landscape) {
      .timer-display {
        font-size: min(32vw, 50dvh, 50vh);
      }
      .scroll-container {
        height: calc(100vh - 300px);
      }
    }

    /* Small height screens (landscape mobile with browser chrome) */
    @media (max-height: 500px) {
      .timer-display {
        font-size: min(28vw, 45dvh, 45vh);
      }
    }

    /* Very small height (landscape mobile with browser chrome) */
    @media (max-height: 400px) {
      .timer-display {
        font-size: min(25vw, 38dvh, 38vh);
      }
    }

    /* Rep counter - 60% of timer size */
    .rep-display {
      font-size: min(27vw, 36dvh, 36vh);
      line-height: 1;
    }
    @media (orientation: landscape) {
      .rep-display {
        font-size: min(19vw, 30dvh, 30vh);
      }
    }
    @media (max-height: 500px) {
      .rep-display {
        font-size: min(17vw, 27dvh, 27vh);
      }
    }
    @media (max-height: 400px) {
      .rep-display {
        font-size: min(15vw, 23dvh, 23vh);
      }
    }

    /* Description - smaller than rep counter */
    .desc-display {
      font-size: min(6vw, 9dvh, 9vh);
      line-height: 1.1;
    }
    @media (orientation: landscape) {
      .desc-display {
        font-size: min(5vw, 7dvh, 7vh);
      }
    }
    @media (max-height: 500px) {
      .desc-display {
        font-size: min(4vw, 6dvh, 6vh);
      }
    }

    /* Control drawer */
    .control-drawer {
      transform: translateX(-100%);
      transition: transform 0.3s ease-in-out;
    }
    .control-drawer.open {
      transform: translateX(0);
    }

    /* Pulse Animations - soft fade in/out ~400ms */
    @keyframes pulse-red {
      0% { opacity: 0; }
      20% { opacity: 0.5; }
      100% { opacity: 0; }
    }
    @keyframes pulse-orange {
      0% { opacity: 0; }
      20% { opacity: 0.5; }
      100% { opacity: 0; }
    }
    @keyframes pulse-green {
      0% { opacity: 0; }
      20% { opacity: 0.6; }
      100% { opacity: 0; }
    }
    @keyframes pulse-rest-warning {
      0% { opacity: 0; }
      20% { opacity: 0.4; }
      100% { opacity: 0; }
    }

    .flash-overlay {
      position: absolute;
      inset: 0;
      pointer-events: none;
      z-index: 5;
    }
    .flash-red { background-color: #ef4444; animation: pulse-red 0.4s ease-in-out forwards; }
    .flash-orange { background-color: #f97316; animation: pulse-orange 0.4s ease-in-out forwards; }
    .flash-green { background-color: #22c55e; animation: pulse-green 0.4s ease-in-out forwards; }
    .flash-rest-warning { background-color: #7c2d12; animation: pulse-rest-warning 0.4s ease-in-out forwards; }

    /* Touch lock overlay */
    .touch-locked::after {
      content: '';
      position: absolute;
      inset: 0;
      z-index: 100;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    function App() {
      const [mode, setMode] = useState('SETUP');
      const [workout, setWorkout] = useState([]);
      const [editingIndex, setEditingIndex] = useState(null);
      const [defaultRest, setDefaultRest] = useState(60);

      const [inReps, setInReps] = useState('4');
      const [inDist, setInDist] = useState('100 Free');
      const [inMin, setInMin] = useState('1');
      const [inSec, setInSec] = useState('30');

      const [currentBlockIndex, setCurrentBlockIndex] = useState(0);
      const [currentRep, setCurrentRep] = useState(1);
      const [timer, setTimer] = useState(0);
      const [isActive, setIsActive] = useState(false);

      // State for rest interval input
      const [restMin, setRestMin] = useState('1');
      const [restSec, setRestSec] = useState('0');

      // New state for settings and features
      const [showSettings, setShowSettings] = useState(false);
      const [showLibrary, setShowLibrary] = useState(false);
      const [showSaveDialog, setShowSaveDialog] = useState(false);
      const [savedWorkouts, setSavedWorkouts] = useState([]);
      const [workoutName, setWorkoutName] = useState('');
      const [touchLockEnabled, setTouchLockEnabled] = useState(false);
      const [touchLocked, setTouchLocked] = useState(false);
      const [isFullscreen, setIsFullscreen] = useState(false);
      const [showDrawer, setShowDrawer] = useState(false);
      const [skipCountdown, setSkipCountdown] = useState(null); // null = not skipping, number = seconds remaining

      // Triple-tap unlock tracking
      const tapTimesRef = useRef([]);
      const TRIPLE_TAP_TIMEOUT = 500; // ms between taps

      // Load saved workouts from localStorage on mount
      useEffect(() => {
        try {
          const saved = localStorage.getItem('swimWorkouts');
          if (saved) {
            setSavedWorkouts(JSON.parse(saved));
          }
        } catch (e) {
          console.log('Failed to load saved workouts:', e);
        }
      }, []);

      // Save workouts to localStorage whenever they change
      const saveToStorage = useCallback((workouts) => {
        try {
          localStorage.setItem('swimWorkouts', JSON.stringify(workouts));
        } catch (e) {
          console.log('Failed to save workouts:', e);
        }
      }, []);

      const handleSaveWorkout = () => {
        if (!workoutName.trim() || workout.length === 0) return;
        const newSaved = [...savedWorkouts, {
          id: Date.now(),
          name: workoutName.trim(),
          workout: workout,
          defaultRest: defaultRest,
          createdAt: new Date().toISOString()
        }];
        setSavedWorkouts(newSaved);
        saveToStorage(newSaved);
        setWorkoutName('');
        setShowSaveDialog(false);
      };

      const handleLoadWorkout = (saved) => {
        setWorkout(saved.workout);
        setDefaultRest(saved.defaultRest);
        setShowLibrary(false);
      };

      const handleDeleteWorkout = (id) => {
        const newSaved = savedWorkouts.filter(w => w.id !== id);
        setSavedWorkouts(newSaved);
        saveToStorage(newSaved);
      };

      // Refs for persistent timing
      const startTimeRef = useRef(null);
      const accumulatedTimeRef = useRef(0);
      const wakeLockRef = useRef(null);
      const ignoreTouchRef = useRef(false); // Multi-touch protection for water splashes

      const formatTime = (seconds) => {
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}:${s < 10 ? '0' : ''}${s}`;
      };

      // Wake Lock API - keeps screen on
      const requestWakeLock = useCallback(async () => {
        if ('wakeLock' in navigator) {
          try {
            wakeLockRef.current = await navigator.wakeLock.request('screen');
            console.log('Wake Lock acquired');
          } catch (err) {
            console.log('Wake Lock failed:', err);
          }
        }
      }, []);

      const releaseWakeLock = useCallback(() => {
        if (wakeLockRef.current) {
          wakeLockRef.current.release();
          wakeLockRef.current = null;
          console.log('Wake Lock released');
        }
      }, []);

      // Handle wake lock based on timer state
      useEffect(() => {
        if (isActive && mode === 'RUN') {
          requestWakeLock();
        } else {
          releaseWakeLock();
        }
        return () => releaseWakeLock();
      }, [isActive, mode, requestWakeLock, releaseWakeLock]);

      // Re-acquire wake lock on visibility change (handles screen off/on)
      useEffect(() => {
        const handleVisibilityChange = () => {
          if (document.visibilityState === 'visible' && isActive && mode === 'RUN') {
            requestWakeLock();
          }
        };
        document.addEventListener('visibilitychange', handleVisibilityChange);
        return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
      }, [isActive, mode, requestWakeLock]);

      // Fullscreen API helpers
      const enterFullscreen = useCallback(async () => {
        try {
          const elem = document.documentElement;
          if (elem.requestFullscreen) {
            await elem.requestFullscreen();
          } else if (elem.webkitRequestFullscreen) {
            await elem.webkitRequestFullscreen();
          } else if (elem.msRequestFullscreen) {
            await elem.msRequestFullscreen();
          }
          setIsFullscreen(true);
        } catch (err) {
          console.log('Fullscreen failed:', err);
        }
      }, []);

      const exitFullscreen = useCallback(() => {
        try {
          if (document.exitFullscreen) {
            document.exitFullscreen();
          } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
          } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
          }
          setIsFullscreen(false);
        } catch (err) {
          console.log('Exit fullscreen failed:', err);
        }
      }, []);

      // Track fullscreen changes (user may exit via Escape key)
      useEffect(() => {
        const handleFullscreenChange = () => {
          const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
          setIsFullscreen(isFs);
          // If user exits fullscreen, also disable touch lock
          if (!isFs && touchLocked) {
            setTouchLocked(false);
          }
        };
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        return () => {
          document.removeEventListener('fullscreenchange', handleFullscreenChange);
          document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
        };
      }, [touchLocked]);

      // Auto-enable touch lock and fullscreen when timer starts (if feature is enabled)
      useEffect(() => {
        if (touchLockEnabled && isActive && mode === 'RUN') {
          enterFullscreen();
          setTouchLocked(true);
        }
      }, [isActive, touchLockEnabled, mode, enterFullscreen]);

      // Handle triple-tap to unlock
      const handleTripleTap = useCallback(() => {
        const now = Date.now();
        const recentTaps = tapTimesRef.current.filter(t => now - t < TRIPLE_TAP_TIMEOUT);
        recentTaps.push(now);
        tapTimesRef.current = recentTaps;

        if (recentTaps.length >= 3) {
          // Triple tap detected - unlock
          setTouchLocked(false);
          exitFullscreen();
          tapTimesRef.current = [];
        }
      }, [exitFullscreen]);

      // Skip countdown effect - counts down from 5, then skips to next rep
      useEffect(() => {
        if (skipCountdown === null) return;

        if (skipCountdown <= 0) {
          // Execute skip - advance to next rep or block
          const currentBlock = workout[currentBlockIndex];
          if (currentBlock) {
            const currentIsRest = currentBlock.type === 'rest';
            startTimeRef.current = performance.now();
            accumulatedTimeRef.current = 0;
            lastDisplayedSecondRef.current = 0;
            setTimer(0);
            if (currentIsRest || currentRep >= currentBlock.reps) {
              setCurrentBlockIndex(prev => prev + 1);
              setCurrentRep(1);
            } else {
              setCurrentRep(prev => prev + 1);
            }
          }
          setSkipCountdown(null);
          setShowDrawer(false);
          // Re-enable touch lock if water-resistant mode is on
          // (fullscreen was already entered when user tapped SKIP button)
          if (touchLockEnabled) {
            setTouchLocked(true);
          }
          return;
        }

        const timeout = setTimeout(() => {
          setSkipCountdown(prev => prev - 1);
        }, 1000);

        return () => clearTimeout(timeout);
      }, [skipCountdown, workout, currentBlockIndex, currentRep, touchLockEnabled]);

      const handleSkipStart = () => {
        // Enter fullscreen NOW (user gesture) so it works on mobile
        // Touch lock will be re-enabled after countdown completes
        if (touchLockEnabled) {
          enterFullscreen();
        }
        setSkipCountdown(5);
      };

      const handleSkipCancel = () => {
        setSkipCountdown(null);
      };

      const handleAddOrUpdate = () => {
        const mins = parseInt(inMin) || 0;
        const secs = parseInt(inSec) || 0;
        const reps = parseInt(inReps) || 1;
        const totalSeconds = (mins * 60) + secs;
        if (totalSeconds <= 0) return;

        const newBlock = { type: 'swim', reps, dist: inDist || "Swim", interval: totalSeconds };
        let newWorkout = [...workout];

        if (editingIndex !== null) {
          newWorkout[editingIndex] = newBlock;
          setEditingIndex(null);
        } else {
          newWorkout.push(newBlock);
        }
        setWorkout(newWorkout);
        setInDist('');
      };

      const handleAddRest = () => {
        const mins = parseInt(restMin) || 0;
        const secs = parseInt(restSec) || 0;
        const totalSeconds = (mins * 60) + secs;
        if (totalSeconds <= 0) return;
        setWorkout([...workout, { type: 'rest', duration: totalSeconds }]);
      };

      // Auto-select text on focus for easier input
      const handleInputFocus = (e) => e.target.select();

      // High-precision timer using requestAnimationFrame and performance.now()
      // This ensures second changes happen within ~16ms of the actual boundary
      const lastDisplayedSecondRef = useRef(-1);

      useEffect(() => {
        let animationId = null;

        const tick = () => {
          if (!isActive || mode !== 'RUN') return;

          const now = performance.now();
          const elapsedMs = now - startTimeRef.current;
          const elapsedSeconds = Math.floor(elapsedMs / 1000);
          const newTimer = accumulatedTimeRef.current + elapsedSeconds;

          // Only update state when the second actually changes
          // This reduces unnecessary renders and ensures precise visual updates
          if (newTimer !== lastDisplayedSecondRef.current) {
            lastDisplayedSecondRef.current = newTimer;
            setTimer(newTimer);
          }

          animationId = requestAnimationFrame(tick);
        };

        if (isActive && mode === 'RUN') {
          // Store start time when timer begins using high-precision timer
          if (startTimeRef.current === null) {
            startTimeRef.current = performance.now();
            accumulatedTimeRef.current = timer;
            lastDisplayedSecondRef.current = timer;
          }
          animationId = requestAnimationFrame(tick);
        } else {
          // Timer paused - save accumulated time
          if (startTimeRef.current !== null) {
            accumulatedTimeRef.current = timer;
            startTimeRef.current = null;
          }
        }

        return () => {
          if (animationId) cancelAnimationFrame(animationId);
        };
      }, [isActive, mode]);

      // Handle visibility changes - recalculate time when returning from background
      useEffect(() => {
        const handleVisibility = () => {
          if (document.visibilityState === 'visible' && isActive && mode === 'RUN' && startTimeRef.current !== null) {
            // Recalculate based on elapsed time since start
            const now = performance.now();
            const elapsedMs = now - startTimeRef.current;
            const elapsedSeconds = Math.floor(elapsedMs / 1000);
            const newTimer = accumulatedTimeRef.current + elapsedSeconds;
            if (newTimer !== lastDisplayedSecondRef.current) {
              lastDisplayedSecondRef.current = newTimer;
              setTimer(newTimer);
            }
          }
        };
        document.addEventListener('visibilitychange', handleVisibility);
        return () => document.removeEventListener('visibilitychange', handleVisibility);
      }, [isActive, mode]);

      // Define block and isRest before they're used in the useEffect below
      const block = workout[currentBlockIndex];
      const isRest = block?.type === 'rest';

      useEffect(() => {
        if (!isActive || mode !== 'RUN') return;
        const currentBlock = workout[currentBlockIndex];
        if (!currentBlock) return;
        const currentIsRest = currentBlock?.type === 'rest';
        const limit = currentIsRest ? currentBlock.duration : currentBlock.interval;

        if (timer >= limit) {
          // Reset timer refs for new interval using high-precision timer
          startTimeRef.current = performance.now();
          accumulatedTimeRef.current = 0;
          lastDisplayedSecondRef.current = 0;
          setTimer(0);
          if (currentIsRest || currentRep >= currentBlock.reps) {
            setCurrentBlockIndex(prev => prev + 1);
            setCurrentRep(1);
          } else {
            setCurrentRep(prev => prev + 1);
          }
        }
      }, [timer, isActive, currentBlockIndex, workout, currentRep]);

      // Settings Modal
      const SettingsModal = () => (
        <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4" onClick={() => setShowSettings(false)}>
          <div className="bg-slate-900 rounded-xl p-6 max-w-md w-full border border-slate-700" onClick={e => e.stopPropagation()}>
            <h2 className="text-xl font-bold text-blue-400 mb-6">Settings</h2>

            {/* Touch Lock Toggle */}
            <div className="mb-6">
              <div className="flex items-center justify-between mb-2">
                <label className="text-white font-medium">Water-Resistant Mode</label>
                <button
                  onClick={() => setTouchLockEnabled(!touchLockEnabled)}
                  className={`w-14 h-8 rounded-full transition-colors ${touchLockEnabled ? 'bg-green-600' : 'bg-slate-600'}`}
                >
                  <div className={`w-6 h-6 bg-white rounded-full transition-transform mx-1 ${touchLockEnabled ? 'translate-x-6' : ''}`}></div>
                </button>
              </div>
              <p className="text-slate-400 text-sm">
                Enables fullscreen and blocks accidental touches from water splashes. Triple-tap the lock icon to unlock.
              </p>
            </div>

            {/* Wake Lock Info */}
            <div className="mb-6 p-4 bg-slate-800 rounded-lg">
              <div className="flex items-center gap-2 mb-1">
                <span className="text-green-400">●</span>
                <span className="text-white font-medium">Screen Stay-On</span>
              </div>
              <p className="text-slate-400 text-sm">
                Screen will stay on automatically while the timer is running.
              </p>
            </div>

            {/* Library Button */}
            <button
              onClick={() => { setShowSettings(false); setShowLibrary(true); }}
              className="w-full py-3 bg-purple-600 rounded-lg font-bold mb-3"
            >
              WORKOUT LIBRARY
            </button>

            <button
              onClick={() => setShowSettings(false)}
              className="w-full py-3 bg-blue-600 rounded-lg font-bold"
            >
              DONE
            </button>
          </div>
        </div>
      );

      // Library Modal
      const LibraryModal = () => (
        <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4" onClick={() => setShowLibrary(false)}>
          <div className="bg-slate-900 rounded-xl p-6 max-w-md w-full border border-slate-700 max-h-[80vh] flex flex-col" onClick={e => e.stopPropagation()}>
            <h2 className="text-xl font-bold text-purple-400 mb-4">Workout Library</h2>

            <div className="flex-grow overflow-y-auto mb-4">
              {savedWorkouts.length === 0 ? (
                <p className="text-slate-400 text-center py-8">No saved workouts yet. Create a workout and save it!</p>
              ) : (
                savedWorkouts.map(saved => (
                  <div key={saved.id} className="bg-slate-800 rounded-lg p-3 mb-2 border border-slate-700">
                    <div className="flex justify-between items-start mb-2">
                      <div>
                        <h3 className="font-bold text-white">{saved.name}</h3>
                        <p className="text-slate-400 text-xs">
                          {saved.workout.filter(b => b.type === 'swim').length} sets
                        </p>
                      </div>
                      <button
                        onClick={() => handleDeleteWorkout(saved.id)}
                        className="text-red-500 hover:text-red-400 p-1"
                      >
                        <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                      </button>
                    </div>
                    <button
                      onClick={() => handleLoadWorkout(saved)}
                      className="w-full py-2 bg-purple-600 hover:bg-purple-500 rounded font-bold text-sm"
                    >
                      LOAD WORKOUT
                    </button>
                  </div>
                ))
              )}
            </div>

            <button
              onClick={() => setShowLibrary(false)}
              className="w-full py-3 bg-slate-700 rounded-lg font-bold"
            >
              CLOSE
            </button>
          </div>
        </div>
      );

      // Save Workout Dialog
      const SaveDialog = () => (
        <div className="fixed inset-0 bg-black/80 flex items-center justify-center z-50 p-4" onClick={() => setShowSaveDialog(false)}>
          <div className="bg-slate-900 rounded-xl p-6 max-w-md w-full border border-slate-700" onClick={e => e.stopPropagation()}>
            <h2 className="text-xl font-bold text-purple-400 mb-4">Save Workout</h2>

            <div className="mb-4">
              <label className="text-slate-400 text-sm block mb-2">Workout Name</label>
              <input
                type="text"
                value={workoutName}
                onChange={e => setWorkoutName(e.target.value)}
                placeholder="e.g., Sprint Set, Endurance, etc."
                className="w-full bg-black p-3 rounded border border-slate-700 text-white"
                autoFocus
              />
            </div>

            <div className="flex gap-2">
              <button
                onClick={() => setShowSaveDialog(false)}
                className="flex-1 py-3 bg-slate-700 rounded-lg font-bold"
              >
                CANCEL
              </button>
              <button
                onClick={handleSaveWorkout}
                disabled={!workoutName.trim()}
                className="flex-1 py-3 bg-purple-600 rounded-lg font-bold disabled:opacity-50"
              >
                SAVE
              </button>
            </div>
          </div>
        </div>
      );

      if (mode === 'SETUP') {
        return (
          <div className="h-screen flex flex-col bg-slate-950 p-4">
            {showSettings && <SettingsModal />}
            {showLibrary && <LibraryModal />}
            {showSaveDialog && <SaveDialog />}
            <div className="flex justify-between items-center mb-4">
              <h1 className="text-xl font-bold text-blue-400">Practice Setup</h1>
              <div className="flex items-center gap-2">
                <span className="text-slate-400 text-sm">{workout.length} items</span>
                {/* Save Button */}
                <button
                  onClick={() => setShowSaveDialog(true)}
                  disabled={workout.length === 0}
                  className="p-2 rounded-lg bg-purple-800 border border-purple-600 hover:bg-purple-700 disabled:opacity-30 disabled:cursor-not-allowed"
                  title="Save Workout"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
                  </svg>
                </button>
                {/* Library Button */}
                <button
                  onClick={() => setShowLibrary(true)}
                  className="p-2 rounded-lg bg-slate-800 border border-slate-700 hover:bg-slate-700"
                  title="Workout Library"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4" />
                  </svg>
                </button>
                {/* Settings Button */}
                <button
                  onClick={() => setShowSettings(true)}
                  className="p-2 rounded-lg bg-slate-800 border border-slate-700 hover:bg-slate-700"
                  title="Settings"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  </svg>
                </button>
              </div>
            </div>
            {/* Swim Set Input */}
            <div className={`p-3 rounded-xl mb-3 border-2 transition-all ${editingIndex !== null ? 'border-yellow-500 bg-slate-900' : 'border-blue-600 bg-slate-900'}`}>
              <div className="grid grid-cols-5 gap-2 mb-2">
                <div className="col-span-1">
                  <label className="text-[10px] text-slate-400">Reps</label>
                  <input type="number" value={inReps} onChange={e => setInReps(e.target.value)} onFocus={handleInputFocus} className="w-full bg-black p-2 rounded text-lg border border-slate-700 text-center" />
                </div>
                <div className="col-span-2">
                  <label className="text-[10px] text-slate-400">Description</label>
                  <input type="text" value={inDist} onChange={e => setInDist(e.target.value)} onFocus={handleInputFocus} className="w-full bg-black p-2 rounded text-lg border border-slate-700" />
                </div>
                <div className="col-span-1">
                  <label className="text-[10px] text-slate-400">Min</label>
                  <input type="number" value={inMin} onChange={e => setInMin(e.target.value)} onFocus={handleInputFocus} className="w-full bg-black p-2 rounded border border-slate-700 text-center" />
                </div>
                <div className="col-span-1">
                  <label className="text-[10px] text-slate-400">Sec</label>
                  <input type="number" value={inSec} onChange={e => setInSec(e.target.value)} onFocus={handleInputFocus} className="w-full bg-black p-2 rounded border border-slate-700 text-center" />
                </div>
              </div>
              <button onClick={handleAddOrUpdate} className={`w-full py-2 rounded-lg font-bold ${editingIndex !== null ? 'bg-yellow-600 text-black' : 'bg-blue-600'}`}>
                {editingIndex !== null ? 'SAVE CHANGES' : 'ADD SET'}
              </button>
            </div>

            {/* Rest Interval Input */}
            <div className="flex gap-2 mb-3">
              <div className="flex items-center gap-1 bg-orange-950/60 border border-orange-600 rounded-lg px-3 py-2">
                <span className="text-orange-400 text-sm font-medium">REST</span>
                <input type="number" value={restMin} onChange={e => setRestMin(e.target.value)} onFocus={handleInputFocus} className="w-10 bg-black p-1 rounded border border-orange-700 text-center text-sm" placeholder="M" />
                <span className="text-orange-400">:</span>
                <input type="number" value={restSec} onChange={e => setRestSec(e.target.value)} onFocus={handleInputFocus} className="w-10 bg-black p-1 rounded border border-orange-700 text-center text-sm" placeholder="S" />
              </div>
              <button onClick={handleAddRest} className="flex-grow py-2 bg-orange-600 hover:bg-orange-500 rounded-lg font-bold text-sm">
                ADD REST
              </button>
            </div>
            <div className="scroll-container">
              {workout.map((b, i) => (
                <div key={i} onClick={() => { if(b.type!=='rest') { setEditingIndex(i); setInReps(b.reps.toString()); setInDist(b.dist); setInMin(Math.floor(b.interval/60).toString()); setInSec((b.interval%60).toString()); }}} className={`flex justify-between p-3 rounded mb-2 border-l-4 ${editingIndex === i ? 'border-yellow-500 bg-slate-800' : b.type === 'rest' ? 'bg-orange-950/40 border-orange-500' : 'bg-black border-blue-600'}`}>
                  <span>{b.type === 'rest' ? `REST: ${formatTime(b.duration)}` : `${b.reps}x${b.dist} @ ${formatTime(b.interval)}`}</span>
                  <button onClick={(e) => { e.stopPropagation(); setWorkout(workout.filter((_, idx) => idx !== i)); }} className="text-red-500 font-bold px-2">✕</button>
                </div>
              ))}
            </div>
            <div className="fixed bottom-0 left-0 right-0 p-4 bg-slate-950 border-t border-slate-800">
               <button onClick={() => { setMode('RUN'); setCurrentBlockIndex(0); setCurrentRep(1); setTimer(0); startTimeRef.current = null; accumulatedTimeRef.current = 0; }} disabled={workout.length === 0} className="w-full py-3 bg-green-600 hover:bg-green-500 disabled:opacity-50 disabled:cursor-not-allowed rounded-lg font-bold text-lg">START PRACTICE</button>
            </div>
          </div>
        );
      }

      // --- RUN MODE ---
      if (!block) {
        // Release touch lock when practice ends
        if (touchLocked) setTouchLocked(false);
        return (
          <div className="h-screen bg-black flex flex-col items-center justify-center">
            <h1 className="text-green-500 text-4xl font-bold mb-8">PRACTICE OVER</h1>
            <button onClick={() => setMode('SETUP')} className="bg-blue-600 px-10 py-4 rounded-xl font-bold">RESTART</button>
          </div>
        );
      }

      const limit = isRest ? block.duration : block.interval;
      const remaining = limit - timer;
      const timerSecond = Math.floor(timer);

      // Calculate display time: count UP for swim, count DOWN for rest
      // For rest: start at duration and count down to 1 (never showing 0)
      // This means a 60-second rest shows 1:00, 0:59, 0:58... 0:02, 0:01
      // Then transitions to work showing 0:00 - no duplicate zeros
      const displayTime = isRest ? Math.max(1, block.duration - timerSecond) : timerSecond;

      // Determine flash class - only triggers once per second via key change
      let flashClass = "";
      if (isActive) {
        if (timerSecond === 0 && !isRest) {
          // Flash green at start of new swim rep
          flashClass = "flash-green";
        } else if (remaining <= 3 && remaining > 0) {
          if (isRest) {
            // Flash during final 3 seconds of rest
            flashClass = "flash-rest-warning";
          } else {
            // Flash during final 3 seconds of swim
            const nextIsRest = (currentRep >= block.reps);
            flashClass = nextIsRest ? "flash-orange" : "flash-red";
          }
        }
      }

      // Key for flash overlay - only changes when timer second changes
      // This ensures the flash animation triggers exactly once per second
      const flashKey = `${currentBlockIndex}-${currentRep}-${timerSecond}`;

      const handleTouchStart = (e) => {
        // Ignore multi-touch (water splashes often register multiple touches)
        if (e.touches && e.touches.length > 1) {
          ignoreTouchRef.current = true;
          e.preventDefault();
          return;
        }
        ignoreTouchRef.current = false;
      };

      const handleTimerClick = (e) => {
        // Ignore if this was a multi-touch event
        if (ignoreTouchRef.current) {
          ignoreTouchRef.current = false;
          return;
        }
        if (touchLocked) return; // Ignore touch when locked
        setIsActive(!isActive);
        if (!isActive) {
          // Resuming - reset start time with high-precision timer
          startTimeRef.current = performance.now();
          accumulatedTimeRef.current = timer;
          lastDisplayedSecondRef.current = timer;
        }
      };

      return (
        <div
          className={`run-container flex flex-col relative ${isRest ? 'bg-orange-500' : 'bg-black'} ${touchLocked ? 'touch-locked' : ''}`}
          onTouchStart={handleTouchStart}
          onClick={handleTimerClick}
        >
          {/* Flash overlay - key changes once per second to trigger animation */}
          {flashClass && (
            <div key={flashKey} className={`flash-overlay ${flashClass}`} />
          )}

          {/* Touch Lock Indicator - tap this 3x to unlock */}
          {touchLocked && (
            <div
              onClick={(e) => { e.stopPropagation(); handleTripleTap(); }}
              className="absolute top-4 left-1/2 -translate-x-1/2 z-[110] bg-red-600 text-white px-4 py-3 rounded-full text-sm font-bold flex items-center gap-2 cursor-pointer active:bg-red-700 select-none"
            >
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
              </svg>
              TAP 3X TO UNLOCK
            </div>
          )}

          {/* Re-lock button - shows when water-resistant mode is enabled but screen is unlocked */}
          {touchLockEnabled && !touchLocked && (
            <div
              onClick={(e) => {
                e.stopPropagation();
                enterFullscreen();
                setTouchLocked(true);
              }}
              onTouchEnd={(e) => {
                e.stopPropagation();
                e.preventDefault();
                enterFullscreen();
                setTouchLocked(true);
              }}
              className="absolute top-4 left-1/2 -translate-x-1/2 z-[110] bg-green-600 text-white px-4 py-3 rounded-full text-sm font-bold flex items-center gap-2 cursor-pointer active:bg-green-700 select-none"
            >
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M10 1a4.5 4.5 0 00-4.5 4.5V9H5a2 2 0 00-2 2v6a2 2 0 002 2h10a2 2 0 002-2v-6a2 2 0 00-2-2h-.5V5.5A4.5 4.5 0 0010 1zm3 8V5.5a3 3 0 10-6 0V9h6z" clipRule="evenodd" />
              </svg>
              TAP TO LOCK
            </div>
          )}

          {/* Menu button - top left */}
          <div className="absolute top-2 left-2 z-[102]">
            <button
              onTouchEnd={(e) => {
                e.stopPropagation();
                e.preventDefault();
                if (touchLocked) return;
                setShowDrawer(!showDrawer);
              }}
              onClick={(e) => {
                e.stopPropagation();
                if (touchLocked) return;
                setShowDrawer(!showDrawer);
              }}
              className={`p-3 rounded-lg ${isRest ? 'bg-orange-600 text-white' : 'bg-slate-800 text-slate-400'} ${touchLocked ? 'opacity-50' : ''}`}
            >
              <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" />
              </svg>
            </button>
          </div>

          {/* Interval display - top right */}
          <div className={`absolute top-3 right-3 z-10 text-sm md:text-base font-medium ${isRest ? 'text-black/60' : 'text-slate-500'}`}>
            @{formatTime(isRest ? block.duration : block.interval)}
          </div>

          {/* Control Drawer */}
          <div
            className={`control-drawer ${showDrawer ? 'open' : ''} absolute top-0 left-0 h-full w-64 bg-slate-900 border-r border-slate-700 z-[105] flex flex-col p-4 overflow-y-auto`}
            onClick={(e) => e.stopPropagation()}
          >
            <div className="flex justify-between items-center mb-4 flex-shrink-0">
              <h2 className="text-lg font-bold text-white">Controls</h2>
              <button
                onClick={() => setShowDrawer(false)}
                className="p-2 text-slate-400 hover:text-white"
              >
                <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                </svg>
              </button>
            </div>

            {/* Edit Button */}
            <button
              onClick={() => {
                setMode('SETUP');
                setIsActive(false);
                setTouchLocked(false);
                setShowDrawer(false);
              }}
              className="w-full py-3 mb-4 bg-blue-600 hover:bg-blue-500 rounded-lg font-bold text-white flex items-center justify-center gap-2 flex-shrink-0"
            >
              <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
              </svg>
              EDIT WORKOUT
            </button>

            {/* Skip Section */}
            <div className="border-t border-slate-700 pt-4 flex-shrink-0">
              <p className="text-slate-400 text-sm mb-3">
                Skip to the next rep with a 5-second countdown. Tap cancel if pressed accidentally.
              </p>
              {skipCountdown === null ? (
                <button
                  onClick={handleSkipStart}
                  className="w-full py-3 bg-yellow-600 hover:bg-yellow-500 rounded-lg font-bold text-black flex items-center justify-center gap-2"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 5l7 7-7 7M5 5l7 7-7 7" />
                  </svg>
                  SKIP TO NEXT REP
                </button>
              ) : (
                <div className="text-center">
                  <div className="text-4xl font-bold text-yellow-400 mb-3">{skipCountdown}</div>
                  <p className="text-white text-sm mb-3">Skipping in {skipCountdown}s...</p>
                  <button
                    onClick={handleSkipCancel}
                    className="w-full py-3 bg-red-600 hover:bg-red-500 rounded-lg font-bold text-white"
                  >
                    CANCEL
                  </button>
                </div>
              )}
            </div>
          </div>

          {/* Drawer backdrop */}
          {showDrawer && (
            <div
              className="absolute inset-0 bg-black/50 z-[104]"
              onClick={(e) => { e.stopPropagation(); setShowDrawer(false); setSkipCountdown(null); }}
            />
          )}

          {/* Main content area */}
          <div className="flex-grow flex flex-col items-center justify-center z-10 overflow-hidden px-4">
            {/* Rep counter and description row - above timer */}
            {!isRest && (
              <div className="flex items-baseline justify-center gap-2 mb-2">
                <span className={`digital-font font-bold rep-display ${isRest ? 'text-black' : 'text-white'}`}>
                  {currentRep}/{block.reps}
                </span>
                <span className={`font-bold desc-display uppercase ${isRest ? 'text-black/70' : 'text-slate-500'}`}>
                  {block.dist}
                </span>
              </div>
            )}
            {isRest && (
              <div className="mb-2">
                <span className="digital-font font-bold rep-display text-black/80">REST</span>
              </div>
            )}

            {/* Timer */}
            <span className={`digital-font font-bold timer-display ${isRest ? 'text-black' : 'text-red-600'}`}>
              {formatTime(displayTime)}
            </span>
          </div>

          {/* Paused overlay */}
          {!isActive && !touchLocked && (
            <div className="absolute inset-0 flex items-center justify-center bg-black/40 z-20">
              <div className="text-yellow-400 text-2xl md:text-4xl font-bold border-4 border-yellow-400 p-3 md:p-4">PAUSED</div>
            </div>
          )}
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
